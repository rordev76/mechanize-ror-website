= Mechanize Release Notes

== 0.5.1

This release is a small bugfix release.  The main bug fixed in this release is
a problem with file uploading.  I have also made some performance improvements
to cookie parsing.

== 0.5.0

Good News first:

This release has many new great features!  Mechanize has been updated to
handle any content type a web server returns using a system called "Pluggable
Parsers".  Mechanize has always been able to handle any content type
(sort of), but the pluggable parser system lets us cleanly handle any
content type by instantiating a class for the content type returned from the
server.  For example, a web server returns type 'text/html', mechanize asks
the pluggable parser for a class to instantiate for 'text/html'.  Mechanize
then instantiates that class and returns it.  Users can define their own
parsers, and register them with the Pluggable Parser so that mechanize will
instantiate your class when the content type you specify is returned.  This
allows you to easily preprocess your HTML, or even use other HTML parsers.
Content types that the pluggable parser doesn't know how to handle will
return WWW::Mechanize::File which has basic functionality like a 'save_as'
method.  For more information, see the RDoc for
WWW::Mechanize::PluggableParser also see the EXAMPLES file.

A 'save_as' method has been added so that any page downloaded can be easily
saved to a file.

The cookie jar for mechanize can now be saved to disk and loaded back up at
another time.  If your script needs to save cookie state between executions,
you can now use the 'save_as' and 'load' methods on WWW::Mechanize::CookieJar.

Form fields can now be treated as accessors.  This means that if you have a
form with the fields 'username' and 'password', you could manipulate them like
this:

  form.username = 'test'
  form.password = 'testing'
  puts "username: #{form.username}"
  puts "password: #{form.password}"

Form fields can still be accessed in the usual way in case there are multiple
input fields with the same name.

Bad news second:

In this release, the name space has been altered to be more consistent.  Many
classes used to be under WWW directly, they are now all under WWW::Mechanize.
For example, in 0.4.7 Page was WWW::Page, in this release it is now
WWW::Mechanize::Page.  This may break your code, but if you aren't using
class names directly, everything should be fine.

Body filters have been removed in favor of Pluggable Parsers.

== 0.4.7

This release of mechanize comes with a few bug fixes including fixing a
bug when there is no action specified in a form.

In this version, a default user agent string is now set for mechanize.  Also
a convenience method WWW::Mechanize#get_file has been added for fetching
non text/html files.

== 0.4.6

The 0.4.6 release comes with proxy support which can be enabled by calling
the set_proxy method on your WWW::Mechanize object.  Once you have set your
proxy settings, all mechanize requests will go through the proxy.

A new "visited?" method has been added to WWW::Mechanize so that you can see
if any particular URL is in your history.

Image alt text support has been added to links.  If a link contains an image
with no text, the alt text of the image will be used.  For example:

  <a href="foo.html><img src="foo.gif" alt="Foo Image"></a>

This link will contain the text "Foo Image", and can be found like this:

  link = page.links.text('Foo Image')

Lists of things have been updated so that you can set a value without
specifying the position in the array.  It will just assume that you want to
set the value on the first element.  For example, the following two statements
are equivalent:

  form.fields.name('q').first.value = 'xyz'  # Old syntax
  form.fields.name('q').value = 'xyz'        # New syntax

This new syntax comes with a note of caution; make sure you know you want to
set only the first value.  There could be multiple fields with the name 'q'.

== 0.4.5

This release comes with a new filtering system.  You can now manipulate the
response body before mechanize parses it.  This can be useful if you know that
the HTML you need to parse is broken, or if you want to speed up the parsing.
This filter can be done on a global basis, or on a per page basis.  Check out
the new examples in the EXAMPLES file for usage.

This release is also starting to phase out the misspelled method
WWW::Mechanize#basic_authetication.  If you are using that method, please
switch to WWW::Mechanize#basic_auth.

The 0.4.5 release has many bug fixes, most noteably better cookie parsing and
better form support.

== 0.4.4

This release of mechanize comes with a new "Option" object that can be
accessed from select fields on forms.  That means that you can figure out
what option to set based on the text in the select field.  For example:

selectlist = form.fields.name('selectlist').first
selectlist.value = selectlist.options.find { |o| o.text == 'foo'}.value

== 0.4.3

The new syntax for finding things like forms, fields, frames, etcetera looks
like this:

page.links.with.text 'Some Text'

The preceding statement will find all links in a page with the text
'Some Text'.  This can be applied to form fields as well:

form.fields.with.name 'email'

These can be chained as well like this:

form.fields.with.name('email').and.with.value('blah@domain.com')

'with' and 'and' can be omitted, and the old way is still supported.  The
following statements all do the same thing:

form.fields.find_all { |f| f.name == 'email' }
form.fields.with.name('email')
form.fields.name('email')
form.fields(:name => 'email')

Regular expressions are also supported:

form.fields.with.name(/email/)

